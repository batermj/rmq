% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rmq.R
\name{r2r.server}
\alias{r2r.server}
\title{Start a server expecting serialized and msgpacked R objects.}
\usage{
r2r.server(handler, addr = rmq.default.addr)
}
\arguments{
\item{handler}{A handler R function taking a single argument}

\item{addr}{A string of "IP:port" format. The server will bind \code{addr}, and it must be available. Defaults to \code{rmq.default.addr}, which is "127.0.0.1:9090".

 @details
 This is an example of how to use \code{rmq.server} to
 good effect. While \code{rmq.server} is designed to allow
 cross-language messaging, it may also be the case
 that only R sessions wish to communicate.
 If both client and server speak R's
 XDR based serialization protocol
 (e.g. if both ends are R sessions), then
 we can \code{serialize()} arbitrary R objects into
 msgpack RAW bytes, transmit those RAW bytes,
 and then \code{unserialize()} the XDR back into full R
 objects. Although not-interoperable with most other
 languages, this does mean that we can exchange
 *any* R object. The msgpack support for language
 interop is limited to numeric arrays, string arrays,
 RAW arrays, integer arrays, lists, and 
 recursively nested lists.
 While this level of msgpack support does cover
 most of the inter-language use cases, sometimes
 we want to serialize full R objects without
 restriction. For such purposes, the approach
 demonstrated in the r2r.server() call and the
 r2r.call() come in handy.

 Caveat: you client-server protocol can no
 longer be evolved by adding new fields to the
 msgpack. If you want to be able to evolve your
 cluster gracefully over time, you may be
 better sticking to msgpack.}
}
\description{
Run a server dedicated to handling R objects. \code{r2r.call}
calls on R's native \code{serialize()} function,
which encodes those bytes in msgpack and sends them over
to a waiting \code{r2r.server}, which turns them back
into R objects before passing them to the handler.
}
\examples{
\dontrun{

 ## R session 1 - start the server, giving it
 ##  a handler to call on arrival of each new message.

 handler = function(x) {
   print("handler called back with argument x = ")
   print(x)
   print("computing and returning x$f(x$arg)")    
   x$f(x$arg)
 }
 r = r2r.server(handler)

 ## lastly the client call - in R session #2
  x=list()
  x$arg=c(1,2,3)
  x$f = function(y) { sum(y) }
  r2r.call(x)
}

}
\seealso{
Other rmq.functions: \code{\link{from.msgpack}},
  \code{\link{r2r.call}}, \code{\link{read.msgpack.frame}},
  \code{\link{read.ndjson}}, \code{\link{rmq.call}},
  \code{\link{rmq.default.addr}}, \code{\link{rmq.server}},
  \code{\link{to.msgpack}}
}

